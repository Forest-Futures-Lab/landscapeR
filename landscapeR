## Author: Dario Masante - www.ceh.ac.uk/staff/dmasan
## September 2015
## 
## This set of functions allows the simulation of categorical maps from scratch in a geographically referenced landscape or 
## the manipulation of existing ones.
## The basic algorithm currently implemented uses a simple agent style/cellular automata growth model,
## with no rules (apart from areas of exclusion) -> expands more or less circularly picking cells at the edges randomly. 
## Fractal and other methods may be implemented. 

## fast matching
is.elem <- function(el, set) {
	fmatch(el, set, 0L) > 0L
}

##### Function to create a SINGLE PATCH. Arguments are: 
##	context: Raster object or matrix, an empty landscape raster or a mask indicating where the patch cannot be generated (see bckgr below).
##	size: size of the patch to be generated
##	spt: integer, the seed point location around which the patch is generated (a random point is given by default)
##	bckgr: integer, value of background cells, where a patch can be generated (default is zero). Forbidden cells must have a different value. 
##	edge: logical, should the vector of edge cells of the patch be returned?
##	rast: logical, if TRUE returns a Raster object, otherwise a vector of cell numbers where the patch falls
##	val: integer, value of patch cells when rast=TRUE
## Returns a vector of MATRIX cell numbers, or the raster directly.

createPatch <- function(context, size, spt = sample.int(length(context),1), bckgr=0, edge=FALSE, rast=FALSE, val=1) {
    if(!is.matrix(context)) {m <- t(as.matrix(context))} else {m <- context}
    bckgr <- which(is.elem(m,bckgr))
    if(length(bckgr) == 0){stop('No cells available, landscape full')}
    if(size > (length(bckgr))){warning('Patch size bigger than available landscape')}
    if(!spt %in% bckgr){
        warning('Seed point within mask. Started from another sampled outside')
        spt <- ifelse(length(bckgr) > 1,sample(bckgr,1),bckgr)
    }
    cg <- spt; edg <- spt
    dim1 <- dim(m)[1]; dim2 <- dim(m)[2]
    while(length(cg) < size){
        if(spt %% dim1 == 0){rr <- dim1; cc <- spt/dim1
        } else {cc <- trunc(spt/dim1) + 1; rr <- spt - (cc-1) * dim1}
        ad <- c(rr-1,rr+1,rr,rr,cc,cc,cc-1,cc+1)
        ad[ad <= 0 | c(ad[1:4] > dim1, ad[5:8] > dim2)] <- NA
        ad <- ad[1:4] + (ad[5:8]-1)*dim1
        ad <- ad[!is.na(ad)]
        ad <- ad[which(!is.elem(ad,c(cg, edg)))]
	## The following stands for {ad <- bckgr[which(bckgr %in% ad)]}
	   d <- fmatch(ad, bckgr, nomatch = 0)
	   ad <- bckgr[d]
        if(length(ad) == 0) {
            edg <- edg[edg!=spt]
            if(length(edg) <= 1) {warning('Maximum patch size reached: ',length(cg)); break}
            spt <- sample(edg,1); next
        }
        cg <- c(cg, ad)
        edg <- c(edg[which(edg != spt)], ad)
        spt <- ifelse(length(edg) == 1, edg, sample(edg,1) )
    }
    if(rast == TRUE) { context[cg]<-val; return(context) 
    } else if (edge == TRUE) {return(list(cg,edg))
    } else {return(cg)}
}

##### Function to create a CLASS OF PATCHES. Arguments are:
##	rst: input raster landscape
##	npatch: number of patches per class
##	size: size of patches (and the value to attribute with raster option). 
## Returns a list of vectors with rast==FALSE, one for each patch generated, or the raster directly with rast==TRUE (default).

createClass <- function(rst, npatch, size, pts =sample.int(length(rst),npatch), bckgrVal=0, edge=FALSE, rast=TRUE, val=1){
	if(rast==TRUE & edge==TRUE){edge=FALSE; warning('Edge output reset to FALSE. edge=TRUE only when raster output is not required (i.e. rast=FALSE)')}
	mtx <- t(as.matrix(rst))
	if(npatch > length(mtx)) {stop('Higher number of patches than landscape cells')}
	if(length(size)==1){size <- rep(size,npatch)}
	if(length(pts) != npatch){stop('Number of patches not matching num. of seed points provided')}
	if(length(size) != npatch){stop('Number of patches not matching length of size vector')}
	lst <- list()
	for(np in 1:npatch){
		l <- createPatch(context=mtx, spt=pts[np], size=size[np], bckgr=bckgrVal, edge=edge)
		if(edge==TRUE){eg <- l[[2]]; l <- l[[1]]; lst[[np]] <- list(l,eg)
		} else {lst[[np]] <- l}
		mtx[l] <- val	
	}
	if(rast == TRUE) { rst[unlist(lst)] <- val; return(rst)	
	} else {return(lst)}
}

##### Function to EXPAND a class of patches. Arguments are:
##	rst: input raster landscape
## class (or patch), 
## size of expansion
## the backgroud available for expansion (i.e. shrinking classes). 
expandClass <- function(rst, class, size, bckgr=0, pts = NULL) {
	bd <- boundaries(rst, type='outer', classes=TRUE, directions=4)
	bd <- t(as.matrix(bd))
	if(!is.matrix(rst)) {m <- t(as.matrix(rst))} else {m <- rst}
	if(is.null(pts)){edg <- which(bd==1 & m==class)} else {edg <- pts}
	bckgr <- which(is.elem(m,bckgr))
	if(length(bckgr) == 0){stop('No cells available, landscape full')}
	if(size > (length(bckgr))){stop('Expansion size bigger than available landscape')}
	pts <- ifelse(length(edg) == 1, edg, sample(edg,1) )
	cg <- pts
	dim1 <- dim(m)[1]; dim2 <- dim(m)[2]
	while(length(cg) < size){
        if(pts %% dim1 == 0){rr <- dim1; cc <- pts/dim1
        } else {cc <- trunc(pts/dim1) + 1; rr <- pts - (cc-1) * dim1}
        ad <- c(rr-1,rr+1,rr,rr,cc,cc,cc-1,cc+1)
        ad[ad <= 0 | c(ad[1:4] > dim1, ad[5:8] > dim2)] <- NA
        ad <- ad[1:4] + (ad[5:8]-1)*dim1
        ad <- ad[!is.na(ad)]
        ad <- ad[which(!is.elem(ad,c(cg, edg)))]
	## The following stands for {ad <- bckgr[which(bckgr %in% ad)]}
	##d <- vapply(ad,function(x) .fastSearch(as.numeric(bckgr),x,"=="),1); ad <- bckgr[d]
	   d <- fmatch(ad, bckgr, nomatch = 0)
	   ad <- bckgr[d]   
        if(length(ad) == 0) {
            edg <- edg[edg!=pts]
            if(length(edg) <= 1) {
			if(length(cg) == 1){warning('Expanding classes do not touch shrinking classes. Input raster returned'); break
			} else {warning('Maximum patch size reached: ',length(cg)); break}
		 }
            pts <- sample(edg,1); next
        }

        cg <- c(cg, ad)
        edg <- c(edg[which(edg != pts)], ad)
        pts <- ifelse(length(edg) == 1, edg, sample(edg,1) )
	}
	rst[cg]=class; return(rst) 
}

##### Function to remove single tones (lonely cells in patches) from rasters
##	rst: input raster landscape
##	rm: logical, if TRUE returns the raster without single tones cells, if FALSE 
##	a vector of numbers identifying the single tones cells 
singletones <- function(rst, rm = TRUE){
	dim1 <- dim(rst)[1]; dim2 <- dim(rst)[2]
	singles <- vector()
	v <- vval <- getValues(rst)
	v <- which(!is.na(v))
	for (pt in v){
		if(pt %% dim2 == 0){cc <- dim2; rr <- pt/dim2
		} else {rr <- trunc(pt/dim2) + 1; cc <- pt - (rr-1) * dim2}
		ad <- c(rr-1,rr+1,rr,rr,cc,cc,cc-1,cc+1)
		ad[ad	 <= 0 | c(ad[1:4] > dim1, ad[5:8] > dim2)] <- NA
		ad <- ad[5:8] + (ad[1:4]-1)*dim2
		ad <- ad[!is.na(ad)]
		if(all(vval[ad] != vval[pt])){
			if(rm == TRUE){
				vval[pt] <- sample(vval[ad],1)
			} else {singles <- c(singles, pt)}
		}
	}
	if(rm == TRUE){rst <- setValues(rst, vval); return(rst)
	} else {return(singles)}
}

